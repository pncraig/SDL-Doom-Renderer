/*
* Created 7:56 PM on 3/24/2023
*/
#include <iostream>
#include "SDL.h"
#include "SDL_image.h"
#include <vector>
#include <fstream>
#include <string>
#include <sstream>
#include"WADLoader.h"
#include "DataTypes.h"

const int WIDTH{ 600 };		// The width of the screen where the 3d rendering occurs
const int HEIGHT{ 460 };	// The height of the whole window

uint32_t* SCREEN = new uint32_t[WIDTH * HEIGHT];	// An array of colors that contains the image generated by the 3d rendering

const Uint8* KEY_STATE{};	// Array which holds the state of each key on the keyboard

const int DISTANCE_TO_SCREEN{ 512 };	// The distance of the player to the projection plane, imaginary but used to scale the projected walls

double PLAYER_X{ 0.0f };
double PLAYER_Y{ 0.0f };
double PLAYER_Z{ 0.0f };
double PLAYER_A{ 0 };		// Angle of the player
double SPEED{ 50.0f };

// Used to calculate frame rate stuff
double PREVIOUS_TIME{};
double CURRENT_TIME{};
double DELTA_TIME{};
double FPS{};



struct Wall
{
	Vertex a{};
	Vertex b{};
	uint32_t color{};
};

struct Sector
{
	int ws{};
	int we{};
	double zb{};
	double zt{};
	double dist{};
};

const int NUM_WALLS{ 8 };
Wall WALLS[] = {
	{ {25.0, 75.0}, {-25.0, 75.0}, 0xFF0000 },
	{ {25.0, 25.0}, {25.0, 75.0}, 0x00FF00 },
	{ {-25.0, 25.0}, {25.0, 25.0}, 0x0000FF},
	{ {-25.0, 75.0}, {-25.0, 25.0}, 0xFF00FF},
	{ {-45.0, 75.0}, {-95.0, 75.0}, 0xFF0000 },
	{ {-45.0, 25.0}, {-45.0, 75.0}, 0x00FF00 },
	{ {-95.0, 25.0}, {-45.0, 25.0}, 0x0000FF},
	{ {-95.0, 75.0}, {-95.0, 25.0}, 0xFF00FF},
};

const int NUM_SECTORS{ 2 };
Sector SECTORS[] = {
	{0, 3, -20.0, 20.0},
	{4, 7, -20.0, 20.0},
};

// Transforms a wall to the player's perspective
Wall transformWall(Wall wall)
{
	double sinOfPlayerA{ sin(PLAYER_A) };
	double cosOfPlayerA{ cos(PLAYER_A) };

	// Translate the coordinates of the wall in the x and y directions
	double x1 = wall.a.x - PLAYER_X;
	double y1 = wall.a.y - PLAYER_Y;
	double x2 = wall.b.x - PLAYER_X;
	double y2 = wall.b.y - PLAYER_Y;

	// Rotate the wall around the player
	double x1r = x1 * cosOfPlayerA - y1 * sinOfPlayerA;
	double y1r = x1 * sinOfPlayerA + y1 * cosOfPlayerA;
	double x2r = x2 * cosOfPlayerA - y2 * sinOfPlayerA;
	double y2r = x2 * sinOfPlayerA + y2 * cosOfPlayerA;

	// Translate the z coordinates of the wall
	wall.a.x = x1r;
	wall.a.y = y1r;
	wall.b.x = x2r;
	wall.b.y = y2r;

	return wall;
}

void drawWall(int xl, int xr, int ylt, int ylb, int yrt, int yrb, uint32_t c)
{
	int dx{ xr - xl };
	int tdy{ yrt - ylt };
	int bdy{ yrb - ylb };

	double topStepY{ static_cast<double>(tdy) / dx };
	double botStepY{ static_cast<double>(bdy) / dx };

	int startX{ std::max(xl, 10) };
	int endX{ std::min(xr, WIDTH - 10) };

	int numberOfExtraSteps{ startX - xl };

	double y1{ static_cast<double>(ylt + (topStepY * numberOfExtraSteps)) };
	double y2{ static_cast<double>(ylb + (botStepY * numberOfExtraSteps)) };

	for (int x{ startX }; x < endX; x++)
	{
		y1 += topStepY;
		y2 += botStepY;

		for (int y{ std::max(static_cast<int>(y1), 10) }; y < std::min(static_cast<int>(y2), HEIGHT - 10); y++)
		{
			SCREEN[y * WIDTH + x] = c;
		}
	}
}

void renderScene()
{
	for (int i{ 0 }; i < NUM_SECTORS; i++)
	{
		int minIndex{ i };
		for (int j{ i + 1 }; j < NUM_SECTORS; j++)
		{
			if (SECTORS[j].dist > SECTORS[minIndex].dist)
				minIndex = j;
		}
		Sector temp{ SECTORS[minIndex] };
		SECTORS[minIndex] = SECTORS[i];
		SECTORS[i] = temp;
	}

	int c{ 0 };
	for(Sector sect : SECTORS)
	{ 
		sect.zb -= PLAYER_Z;
		sect.zt -= PLAYER_Z;

		double xSum{};
		double ySum{};
		for (int j{ 0 }; j < 2; j++)
		{
			for (int i{ sect.ws }; i < sect.we + 1; i++)
			{
				Wall wall = transformWall(WALLS[i]);

				xSum += wall.a.x;
				ySum += wall.a.y;

				// When the wall has been transformed to the player's perspective, the y-coordinate of the wall represents depth. A positive y-coordinate means
				// that the point is in front of the player, but a negative means that the point is behind the player. If both of the 
				// vertices of the wall are behind the player, then don't draw the wall.
				if (wall.a.y <= 0.0 && wall.b.y <= 0.0)
					continue;

				// If one of the vertices of the wall is behind the player, then I have to clip the wall so that I can render it.
				// In order to do this, I find the intersection of the wall segment with the x-axis
				if (wall.a.y <= 0.0)
				{
					wall.a.x = (wall.a.x * wall.b.y - wall.b.x * wall.a.y) / (wall.b.y - wall.a.y);	// Calculate the new x of the wall
					wall.a.y = 0.01;	/* Technically, when the wall segment intersects the x - axis, the y - coordinate of the intersection is 0.
										   However, if the y is 0, then I can't project the wall because of the divide by 0 error, so instead
										   I make the y very small*/
				}
				else if (wall.b.y <= 0.0)
				{
					wall.b.x = (wall.a.x * wall.b.y - wall.b.x * wall.a.y) / (wall.b.y - wall.a.y);
					wall.b.y = 0.01;
				}

				// Project the wall vertices onto the screen using similar triangles
				int screenX1{ static_cast<int>((wall.a.x * DISTANCE_TO_SCREEN) / wall.a.y) + WIDTH / 2 };
				int screenX2{ static_cast<int>((wall.b.x * DISTANCE_TO_SCREEN) / wall.b.y) + WIDTH / 2 };

				int screenY1b{ static_cast<int>((sect.zt * DISTANCE_TO_SCREEN) / wall.a.y) + HEIGHT / 2 };
				int screenY1t{ static_cast<int>((sect.zb * DISTANCE_TO_SCREEN) / wall.a.y) + HEIGHT / 2 };

				int screenY2b{ static_cast<int>((sect.zt * DISTANCE_TO_SCREEN) / wall.b.y) + HEIGHT / 2 };
				int screenY2t{ static_cast<int>((sect.zb * DISTANCE_TO_SCREEN) / wall.b.y) + HEIGHT / 2 };

				if(j == 1)
					drawWall(screenX1, screenX2, screenY1t, screenY1b, screenY2t, screenY2b, wall.color);
				else
					drawWall(screenX2, screenX1, screenY2t, screenY2b, screenY1t, screenY1b, wall.color);
			}
		}

		double avgX{ xSum / (sect.we - sect.ws + 1) };
		double avgY{ ySum / (sect.we - sect.ws + 1) };
		double avgZ{ (sect.zb + sect.zt) / 2.0 };

		SECTORS[c].dist = sqrt(avgX * avgX + avgY * avgY + avgZ * avgZ);
		c++;
	}
}

int main(int argc, char* argv[])
{
	/*
		// SDL_Init() returns a negative number upon failure, and SDL_INIT_EVERYTHING sets all the flags to true
	if (SDL_Init(SDL_INIT_EVERYTHING) != 0)
		std::cout << "Error initializing SDL: " << SDL_GetError() << '\n';	// SDL_GetError() returns information about an error that occurred in a string

	// VVVVVVVVVVVVVVVVVVVVVVV Put image flags here
	int imgFlags{ IMG_INIT_PNG };
	if (!(IMG_Init(imgFlags) & imgFlags))
		std::cout << "Error initializing IMG: " << IMG_GetError() << '\n';

	// SDL_CreateWindow() creates a window
	//								Window name	  Window X position     Window Y position   width height    flags
	//									 V			      V						V			   V    V         V
	SDL_Window* win{ SDL_CreateWindow("Game", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, WIDTH * 2, HEIGHT,       0) };
	SDL_Renderer* renderTarget{ SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED) };

	SDL_Texture* frameBuffer{ SDL_CreateTexture(renderTarget, SDL_PIXELFORMAT_RGB888, SDL_TEXTUREACCESS_STREAMING, WIDTH, HEIGHT) };

	bool isRunning{ true };
	SDL_Event ev{};

	// Game loop
	while (isRunning)
	{
		PREVIOUS_TIME = CURRENT_TIME;
		CURRENT_TIME = SDL_GetTicks() / 1000.0;
		DELTA_TIME = CURRENT_TIME - PREVIOUS_TIME;
		FPS = 1.0 / DELTA_TIME;

		// Output FPS and angle info
		std::cout << "FPS: " << FPS << "        \n";

		// Return the cursor in the console to twelve lines above so that old information is written over
		std::cout << "\x1b[1F";

		// Get keys
		KEY_STATE = SDL_GetKeyboardState(NULL);

		// Event loop
		while (SDL_PollEvent(&ev) != 0)
		{
			switch (ev.type)
			{
				// Check if the exit button has been clicked
				case SDL_QUIT:
					isRunning = false;
				break;

				// Check for window events
				case SDL_WINDOWEVENT:
					// If the window is minimized, wait for events. Fixes memory spikes
					if (ev.window.event == SDL_WINDOWEVENT_MINIMIZED)
					{
						while (SDL_WaitEvent(&ev))
						{
							if (ev.window.event == SDL_WINDOWEVENT_RESTORED)
								break;
						}
					}
				break;
			}
		}

		for (int i = 0; i < WIDTH * HEIGHT; i++)
		{
			SCREEN[i] = 0x000000;
		}

		double xSpeed{};
		double ySpeed{};

		if (KEY_STATE[SDL_SCANCODE_W])
		{
			xSpeed = SPEED * sin(PLAYER_A) * DELTA_TIME;
			ySpeed = SPEED * cos(PLAYER_A) * DELTA_TIME;
		}
		
		if (KEY_STATE[SDL_SCANCODE_S])
		{
			xSpeed = -SPEED * sin(PLAYER_A) * DELTA_TIME;
			ySpeed = -SPEED * cos(PLAYER_A) * DELTA_TIME;
		}

		if (KEY_STATE[SDL_SCANCODE_UP])
			PLAYER_Z -= SPEED * DELTA_TIME;

		if (KEY_STATE[SDL_SCANCODE_DOWN])
			PLAYER_Z += SPEED * DELTA_TIME;

		if (KEY_STATE[SDL_SCANCODE_LSHIFT])
		{
			if (KEY_STATE[SDL_SCANCODE_A])
			{
				xSpeed = SPEED * sin(PLAYER_A - M_PI / 2) * DELTA_TIME;
				ySpeed = SPEED * cos(PLAYER_A - M_PI / 2) * DELTA_TIME;
			}

			if (KEY_STATE[SDL_SCANCODE_D])
			{
				xSpeed = SPEED * sin(PLAYER_A + M_PI / 2) * DELTA_TIME;
				ySpeed = SPEED * cos(PLAYER_A + M_PI / 2) * DELTA_TIME;
			}
		}
		else
		{
			if (KEY_STATE[SDL_SCANCODE_A])
				PLAYER_A -= SPEED * DELTA_TIME * 0.05;
			if (KEY_STATE[SDL_SCANCODE_D])
				PLAYER_A += SPEED * DELTA_TIME * 0.05;
		}

		PLAYER_X += xSpeed;
		PLAYER_Y += ySpeed;

		renderScene();

		SDL_SetRenderDrawColor(renderTarget, 0, 0, 0, 255);
		SDL_RenderClear(renderTarget);

		SDL_SetRenderDrawColor(renderTarget, 255, 0, 0, 0);
		SDL_RenderDrawLine(renderTarget, WIDTH, 0, WIDTH, HEIGHT);

		// Draw the overhead view of the map
		SDL_SetRenderDrawColor(renderTarget, 255, 255, 255, 255);

		SDL_Rect r{ WIDTH / 2 - 2 + WIDTH, HEIGHT / 2 - 2, 4, 4 };
		SDL_RenderFillRect(renderTarget, &r);

		SDL_RenderDrawLineF(renderTarget, WIDTH / 2.0 + WIDTH, HEIGHT / 2.0, WIDTH / 2.0 + WIDTH, HEIGHT / 2.0 - 10);

		for (int i{ 0 }; i < 8; i++)
		{
			Wall wall{ transformWall(WALLS[i]) };
			SDL_RenderDrawLine(renderTarget, wall.a.x + WIDTH / 2 + WIDTH, -wall.a.y + HEIGHT / 2, wall.b.x + WIDTH / 2 + WIDTH, -wall.b.y + HEIGHT / 2);
		}

		// Update the texture that will be drawn to the screen with the array of pixels
		SDL_UpdateTexture(frameBuffer, NULL, SCREEN, WIDTH * sizeof(uint32_t));

		SDL_Rect halfScreen{ 0, 0, WIDTH, HEIGHT };
		SDL_RenderCopy(renderTarget, frameBuffer, NULL, &halfScreen);

		SDL_RenderPresent(renderTarget);
	}

	SDL_DestroyWindow(win);				// Deallocates window memory + winSurface
	SDL_DestroyRenderer(renderTarget);	// Deallocates the renderer

	SDL_Quit();
	IMG_Quit();
	*/

	WADLoader wad{ "DOOM.WAD" };

	wad.load();

	delete[] SCREEN;

	return 0;
}